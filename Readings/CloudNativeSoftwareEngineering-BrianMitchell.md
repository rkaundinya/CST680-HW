I found the most interesting parts of the paper the areas which talked about polyglot programming, usage of the edge, and designing for functionality when disconnected to the cloud. 

The idea of polyglot programming was intriguging because it motivates thinking on the fundamentals of a programming language you choose. Less so from user level questions like: do I like the syntax, am I familiar with this language, is my code historically in this language, etc. It motivates thinking along the lines of what are the fundamental strengths and weaknesses of the design choices of this programming language itself. For example with java, do we need a virtual machine anymore when we design cloud architecture to include that for us? Are there perhaps code on demand endpoint deployment to edge devices however which could benefit from code written in java? Is the Go language’s strength in building API’s useful for me when creating functions which interact with the cloud? Do these functions perhaps call native deployed C code on my cloud server which enables ease of interaction and API building but optimal efficiency in code execution? Is rust’s strength in building parallelized code useful for me? These fundamental language considerations from a “software engineer” perspective become more important than preference, history, library compatibility, etc. 

The modern cloud architecture diagram and discussion on using edge devices highlighted another important consideration of the cloud. The cloud is able to take advantage of compute from various edge devices as well as servers in the main cloud data center. These edge devices can be used to provide telemetry, to cache some data which the cloud program can use on demand, can be used to collect specifics data on program usage, etc. When writing a cloud driven program, you have the ability to take advantage of edge devices almost as auxiliary data caches or sensors. This motivates the cloud native software engineer to consider the types of edge devices they are expecting the program to be used on and therefore can consider ways to take advantage of these devices. 

This plays into the final interesting point from the article – designing your program to be robust to disconenctions from the cloud. I remember speaking to a scientist at UC Irvine about building software robust to attacks from particles for devices deployed in space. One technique they use is to have programs execute within the context of a state machine. This state machine decides whether the program is in a good state or not. If a particle has impacted the device changing the compute to an unexpected or invalid result, the state can be set to something which triggers a reset of the device or a fallback computation. You can build a state machine which allows the program to be robust to interference. While disconnections from the cloud may not need a state machine type program, it could benefit from this type of design. Perhaps when disconnected, there is a state the program operates in. The example in the paper was an online shopping platform which allows you to still add things to cart (likely in a local device cache) but not check out until reconnected. Another example I’m acquainted with is when you use spotify to play a song in an album, it usually loads the whole song onto your device cache and a few songs before and after. That way if you get disconnected from the internet, the device is able to continue playing without interruption even to the point where you can play ahead a few songs in the album before hitting a buffer. 

All these considerations are ones you can take advantage of as a cloud native software engineer and can design around. When you’re utilizing the cloud, you have the advantage of both using the edge devices and the cloud compute. This gives you a lot of tools and a lot of design choices which may not otherwise be available to you. 
